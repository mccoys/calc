<!DOCTYPE HTML>
<html>

<head>
<meta charset="UTF-8"/>
<style type="text/css">
<!--
	html, body { margin:0; padding:0; height:100%; width:100%}
	body { background:#fff; }
	#cont { height:100%; width:100%; display:table; text-align:center; }
	#cont > div { width:100%; margin:0 auto; vertical-align:top; }
	textarea {
		padding:3px; margin:0;
		-webkit-box-shadow: 0 0 4px #bbb; -moz-box-shadow: 0 0 4px #bbb;
		box-shadow: 0 0 4px #bbb;
		background: #f8f8f8; color:#888; border:none; outline:none;
		-webkit-appearance:none; -moz-appearance:none; appearance:none;
		text-align:center; font: 15px sans-serif; line-height:15px;
		width:600px; resize:none;
	}
	#outcont, #hcont { width:600px; padding:3px; margin:0 auto; }
	#out, #help1, #help2 { margin:0}
	#outcont { min-height:100px; background-color:none;}
	#out { padding:20px 0 20px 0; font:19px serif; color:#777;}
	#hcont { min-height:15px; background-color:#eee; box-shadow: 0 0 4px #bbb;
		-webkit-box-shadow: 0 0 4px #bbb; -moz-box-shadow: 0 0 4px #bbb; }
	#help1, #help2, #help3 { float:left; font:15px serif; color:#777; cursor:pointer }
	#help1 { margin-left:100px; }
	#help2 { margin-left:130px; }
	#help3 { margin-left:130px; }
	#help1c, #help2c, #help3c {
		clear:both; width:100%; height:300px;
		display:none; overflow:auto; font:15px serif; color:#777;
	}
	.t { width:100%; border:0; border-collapse:collapse; }
	.t td:nth-child(1) { width:250px; text-align:right; }
	.t td:nth-child(2) { width:100px; text-align:center; }
	.t td:nth-child(3) { width:250px; text-align:left; }
	.graphcont{ width:600px; height:300px; padding:0;
		margin:0 auto; border:1px solid #dddddd; position:relative}
	
-->
</style>
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBACAAEAAQCwAAAAFgAAACgAAAAQAAAAIAAAAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYWFgAAAAAAP8AAAD/AAAA//8AAP//AAD//AAA//gAAD/4AAAf+AAAH/gAAB/8AAAf/wAAP/8AAP//AAD//wAAAP8AAAD/AAD/AAAA/wAAAP//AAD//wAA//wAAP/4AAA/+AAAH/gAAB/4AAAf/AAAH/8AAD//AAD//wAA//8AAAD/AAAA/wAA"/>
<script language="javascript">
<!--
	var svgns="http://www.w3.org/2000/svg";
	
	// Add functions to SVG elements
	SVGElement.prototype.sets = function(att) { // set multiple attributes at once
		for(var key in att) { this.setAttribute(key, att[key]); }
	}
	SVGElement.prototype.Group = function() {
		var e=document.createElementNS(svgns,"g");
		return this.appendChild(e);
	}
	SVGElement.prototype.Line = function(x1,y1,x2,y2,stroke,thickness,dash) {
		var e=document.createElementNS(svgns,"line");
		if(!dash) { dash="none"; }
		e.sets({"x1":""+x1, "y1":""+y1, "x2":""+x2, "y2":""+y2, "stroke-dasharray":dash,
			"vector-effect":"non-scaling-stroke", "stroke-width":thickness, "stroke":stroke });
		return this.appendChild(e);
	};
	SVGElement.prototype.Rect = function(x,y,w,h,fill,stroke,thickness) {
		var e=document.createElementNS(svgns,"rect");
		e.sets({"x":""+x, "width":""+w, "y":""+y, "height":""+h, "stroke":stroke,
			"stroke-width":thickness, "fill":fill, "vector-effect":"non-scaling-stroke" });
		return this.appendChild(e);
	};
	SVGElement.prototype.Polyline = function(points,stroke,thickness,dash) {
		var e=document.createElementNS(svgns,"polyline");
		if(!dash) { dash="none"; }
		e.sets({"points":points, "vector-effect":"non-scaling-stroke",
			"fill":"none", "stroke":stroke, "stroke-width":thickness, "stroke-dasharray":dash });
		return this.appendChild(e);
	};
	SVGElement.prototype.Path = function(pathdata,stroke,thickness,dash) {
		var e=document.createElementNS(svgns,"path");
		if(!dash) { dash="none"; }
		e.sets({"d":pathdata, "vector-effect":"non-scaling-stroke",
			"fill":"none", "stroke":stroke, "stroke-width":thickness, "stroke-dasharray":dash });
		return this.appendChild(e);
	};
	SVGElement.prototype.Text = function(str,x,y,fontsize,color,align,rot) {
		var t=document.createElementNS(svgns,"text");
		t.sets({"x":x+"","y":y+"","fill":color});
		if(fontsize) { t.setAttribute("font-size",fontsize+""); }
		t.textContent = str;
		this.appendChild(t);
		t.move(x,y,align,rot);
		return t;
	};
	SVGTextElement.prototype.move = function(x,y,align,rot) {
		// 'align' can contain NW, NE, NC, SW, SE, SC, MW, ME, or MC
		var b=this.getBBox(); var tw=parseFloat(b.width), th=parseFloat(b.height)*0.5;
		if (align==undefined) {align='SW';}
		tw = tw*[0,.5,1]["WCE".indexOf(align[1])];
		th = th*[0,.5,1]["SMN".indexOf(align[0])];
		this.sets({"x":x-tw, "y":y+th});
		// Now rotate
		if (rot==undefined) { rot=""; }
		if (rot.length>0) { this.setAttribute("transform","rotate("+rot+","+x+","+y+")"); }
	};
	SVGTextElement.prototype.Tspan = function(str,dy) {
		var t=document.createElementNS(svgns,"tspan");
		t.setAttribute("dy",dy);
		t.textContent = str;
		return this.appendChild(t);
	};
	SVGElement.prototype.ZoomButton = function(x,y,w,h,type) {
 		var zoom=this.Group();
 		zoom.Rect(x,y,w,h,"#eee","#ccc",1);
 		zoom.plot=this.firstChild;
 		zoom.onmousedown=zoomBegin;
 		zoom.setAttribute("cursor","pointer");
 		if(type=="+") {zoom.Line(x+w/2,y+h/5,x+w/2,y+4*h/5,"#777",1.5);}
 		zoom.Line(x+w/5,y+h/2,x+4*w/5,y+h/2,"#777",1.5);
  		return zoom;
 	};
 	
	// Functions controling the SVG plot
	function findBestBounds(plot) { // Find the best plot limits automatically
		var xm,xM,ym,yM,f=plot.curveEq;
		var m=Math.log(1e-50),M=Math.log(1e20);
		var i,j,k,kk,lnx,x,y,prevx,dxm,dxM,dx,dy,okm=false,okM=false, prec;
		// The first step is to find a range containing finite values of the function
		for(k=1000; k<=100000; k*=10) { // several attemps, refining the resolution each time
			dx=(M-m)/k;
			// First, negative (positive) numbers for finding left (right) boundary
			for(lnx=M; lnx>=m; lnx-=dx) {
				if(okm && okM) { break; }
				x=Math.exp(lnx);
				if(!okm && Math.abs(f(-x))<1e30) { xm=[-(prevx||x),-x]; okm=true; }
				if(!okM && Math.abs(f( x))<1e30) { xM=[ x,  prevx||x ]; okM=true; }
				prevx=x;
			}
			// Second, positive (negative) numbers for finding left (right) boundary
			for(lnx=m; lnx<=M; lnx+=dx) {
				if(okm && okM) { break; }
				x=Math.exp(lnx);
				if(!okm && Math.abs(f( x))<1e30) { xm=[  prevx||x , x]; okm=true; }
				if(!okM && Math.abs(f(-x))<1e30) { xM=[-x,-(prevx||x)]; okM=true; }
				prevx=x;
			}
			if(okm && okM) { break; }
		}

		// If could not find finite numbers, then error
		if(!okm || !okM) { return false; }
		// Refine the xm and xM locations
		okm=false; okM=false; prec=1e-10; // prec is precision
		dxm=(xm[1]-xm[0])*prec; dxM=(xM[1]-xM[0])*prec;
		while(!okm || !okM) {
			if(xm[1]-xm[0]>0) { dxm=Math.min((xM[1]-xm[0])*prec,dxm); }
			if(xM[1]-xM[0]>0) { dxM=Math.min((xM[1]-xm[0])*prec,dxM); }
			if(!okm && xm[1]-xm[0]<=dxm) { okm=true; }
			if(!okM && xM[1]-xM[0]<=dxM) { okM=true; }
			if(!okm) {
				x=(xm[0]+xm[1])*.5;
				if(Math.abs(f(x))<1e100) { xm[1]=x; } else { xm[0]=x; }
			}
			if(!okM) {
				x=(xM[0]+xM[1])*.5;
				if(Math.abs(f(x))<1e100) { xM[0]=x; } else { xM[1]=x; }
			}
		}
		xm=xm[1]; xM=xM[0]; // Now we have the global x boundaries
		//alert(xm+"  "+xM);

		// Adaptatively find best x range
		plot.x_=new Array(5); plot.y_=new Array(5);
		// First, we define a function for adaptative refinement
		plot.adaptative = function(x0,x1,depth,eps) {
			if(depth>=this.maxdepth) {return depth;}
			this.dx=(x1-x0)*0.25;
			this.x_[0]=x0; this.x_[1]=x0+this.dx; this.x_[2]=x0+2*this.dx; this.x_[3]=x0+3*this.dx; this.x_[4]=x1;
			this.y0=Number.MAX_VALUE; this.y1=-Number.MAX_VALUE;
			for(this.k=0;this.k<5;this.k+=1) {
				this.y_[this.k]=this.curveEq(this.x_[this.k]);
				if(this.y_[this.k]<this.y0) { this.y0=this.y_[this.k]; } // find local min
				if(this.y_[this.k]>this.y1) { this.y1=this.y_[this.k]; } // find local max
			}
			if(this.y0*this.y1>0) { // pb of numerical precision
				if(Math.abs(this.y1-this.y0)<1e-6*Math.max(Math.abs(this.y0),Math.abs(this.y1))) {return depth;}
			}
			this.k=1; this.i=this.y_[1]-this.y_[0];
			while(this.k<4) {
				this.j=this.y_[this.k+1]-this.y_[this.k];
				if(this.i*this.j<0) {break;}
				this.i=this.j; this.k+=1;
			}
			this.refine=false;
			if(this.k<4) { // if oscillating, refine
				this.refine=true;
			} else { // if not oscillating, check if smooth enough
				this.q1=this.y_[0]-5.*this.y_[1]+19.*this.y_[2]+9.*this.y_[3]; // first quadrature
				this.q2=10.*this.y_[2]+16.*this.y_[3]-2.*this.y_[4]; // second quadrature
				if(Math.abs(this.q2-this.q1)>eps*Math.abs(this.q2)) { this.refine=true; }
			}
			if(this.refine) {
				return Math.max(
					this.adaptative(x0,this.x_[2],depth+1,eps*2),
					this.adaptative(this.x_[2],x1,depth+1,eps*2) );
			}
			return depth;
		}
		// Define initial x values
		x=new Array(100); var u=new Array(99);
		x.linspace(xm,xM);
		// First refinement
		var ok=false, kmax=100, i0, i1, xlim=[xm,xM], xmax, xmM;
		plot.maxdepth=1;
		for(k=0; k<kmax; k+=1) {
			for(i=0; i<99; i+=1) { u[i]=plot.adaptative(x[i],x[i+1],0,1e-6); }
			i0=u.indexOf(1);
			if(i0<0) {
				if(!ok) { x.shrinkTowards0(0.02); }
				else    { dx=(x[50]-x[49])*0.3; x.linspace(x[0]+dx,x[99]+dx); }
			} else {
				ok=true; i1=u.lastIndexOf(1);
				if(i0==0 && i1==98) { break; }
				x.linspace(x[i0],x[i1+1]);
			}
			xmax=Math.max(Math.abs(x[99]),Math.abs(x[0]));
			if(Math.abs(x[99]-x[0])<Math.max(1e-20, 0.01*xmax)) { k=kmax; break; }
		}
		xmM=adjustWith0(x[0], x[99], k>=kmax-1);
		xm=Math.max(xm,xmM[0]); xM=Math.min(xM,xmM[1]);
		//alert(xm+"  "+xM);
		// Second refinement
		if(k<kmax-1) {
			x.linspace(xm,xM);
			plot.maxdepth=4; kmax=40; k=0; ok=false;
			var utot, umax, v0, v1, vtot, j0, j1, v=new Array(100);
			while(k<kmax) {
				k+=1;
				if(k>kmax-5 && plot.maxdepth<9) { k=1; plot.maxdepth+=1; }
				utot=0; umax=0; v[99]=0;
				for(i=0; i<99; i+=1) {
					u[i]=plot.adaptative(x[i],x[i+1],0,4e-7);
					if(u[i]>umax) { umax=u[i]; }
					v[i]=(u[i]>=plot.maxdepth)?1:0;
					if(v[i]) { utot+=1; }
				}
				//alert(u);
				// utot is the number of maximal refinement locations
				if(utot>1) {
					i0=v.indexOf(1); i1=v.lastIndexOf(1);
					// If there are several places where max-refinement has been found,
					// we calculate vtot, the number of "switches" from maximal to non-maximal refinement
					v0=0; vtot=0;
					for(j=0; j<100; j+=1) {
						v1=v[j];
						if(v0!=v1) { vtot+=1; v[j]=1; } else { v[j]=0; }
						v0=v1;
					}
					// now j0 the second switch, j1 the penultimate switch
					if(vtot<=3 || vtot>20) {
						if(utot>=99) {
							x.shrinkTowards0(Math.max(0.1,Math.min(0.9,Math.pow(2,-plot.maxdepth*(utot/100)))));
						} else {
							if(i0==1 && i1==98) { break; }
							x.linspace(x[i0],x[i1+1]);
							if(utot<50 && plot.maxdepth<9) { k=1; plot.maxdepth+=1; }
						}
					} else if(vtot>6) {
						// If a bit too many switches, we remove the first and last ones
						j0=v.indexOf(1); j0=v.indexOf(1,j0+1); // second switch
						j1=v.lastIndexOf(1); j1=v.lastIndexOf(1,j1-1); // penultimate switch
						x.linspace(x[j0],x[j1+1]);
					} else break;
				} else {
					// If zero or one max-refinement locations found,
					// then consider reducing the range to the half-width
					umax*=0.5;
					for(i=0; i<99; i+=1) { u[i]=(u[i]>=umax)?1:0; }
					i0=u.indexOf(1); i1=u.lastIndexOf(1);
					if(i0==0 && i1==98) {
						if(!ok) { ok=true; x.shrinkTowards0(1.001); continue; }
						break;
					}
					x.linspace(x[i0],x[i1+1]);
				}
				ok=false;
				xmax=Math.max(Math.abs(x[99]),Math.abs(x[0]));
				if(Math.abs(x[99]-x[0])<Math.max(1e-20, 0.01*xmax)) { k=kmax; break; }
			}
			xmM=adjustWith0(x[0], x[99], k>=kmax-1);
			xm=Math.max(xm,xmM[0]); xM=Math.min(xM,xmM[1]);
		}
		// If bug, then reset to default
		if(k==1 || !isFinite(xm) || !isFinite(xM) || Math.abs(xM-xm)/Math.max(Math.abs(xm),Math.abs(xM))<1e-6) {
			xlim.shrinkTowards0(4/(xlim[1]-xlim[0]));
			xm=xlim[0]; xM=xlim[1];
		}
		//alert([xm,xM]);

		// X range is now found.
		// Find best Y range
		y=[]; dx=(xM-xm)/999.;
		var l;
		for(k=0;k<999;k+=1) { l=f(xm+dx*k); if(isFinite(l)) { y.push(l); } }
		l=f(xM); if(isFinite(l)) { y.push(l); }
		y.sort(function(a,b) {return a-b;});
		//alert(y);
		l=y.length;
		ym=y[0]; yM=y[l-1];
		var yh=new Array(11), dk, hmax;
		for(i=0;i<30;i+=1) {
			dy=(yM-ym)*0.1;
			// compute histogram yh in 10 bins
			yh[0]=0; yh[10]=l-1; dk=100; hmax=0;
			for(k=1;k<10;k+=1) {
				if(yh[k-1]>=l-1) { yh[k]=l-1; continue; }
				dk=Math.ceil((l-yh[k-1])/(11-k));
				yh[k]=yh[k-1]; y0=ym+dy*k;
				while(dk>1) {
					if(yh[k]+dk>l-2 || y[yh[k]+dk]>y0) { dk=Math.floor(dk*0.5); }
					else { yh[k]+=dk; }
				}
			}
			for(k=0;k<10;k+=1) {
				yh[k]=yh[k+1]-yh[k];
				if(yh[k]>hmax) {hmax=yh[k];}
			}
			// Reduce where histogram contains more than 99% of data
			hmax*=0.01;
			for(k=0;k<10;k+=1) { yh[k]=(yh[k]>hmax)?1:0; }
			i0=yh.indexOf(1); i1=yh.lastIndexOf(1);
			if(i0==0 && i1>=9) { break; }
			ym=ym+dy*i0; yM=ym+dy*(i1+1);
		}
		// Adjust y range
		if(Math.abs(yM+ym)<yM*0.5) { yM=(yM-ym)*0.5; ym=-yM; }
		if(yM>0 && ym>0 && ym<yM/5) { ym=0; }
		if(yM<0 && ym<0 && yM>ym/5) { yM=0; }
		// Adjust x range
		k=-1;
		do { k+=1; y0=f(xm+dx*k); } while(y0<ym || y0>yM)
		xm=xm+dx*k;
		k=-1;
		do { k+=1; y0=f(xM-dx*k); } while(y0<ym || y0>yM)
		xM=xM-dx*k;
		// Final adjustment
		dx=(xM-xm)/10; xm-=dx; xM+=dx;
		dy=(yM-ym)/10; ym-=dy; yM+=dy;
		//alert([xm,xM,ym,yM]);
		return [xm,xM,ym,yM];
	}
	SVGGElement.prototype.init = function(x1,x2,y1,y2,w,h) { // Define plot limits, scalings etc
		var i;
		// Define plot positions, etc.
		this.x1=x1; this.x2=x2; this.y1=y1; this.y2=y2;
		this.b=[w,h]; // box size
		this.s=[w/(x2-x1), h/(y1-y2)]; // scalings
		this.t=[-x1*this.s[0], -y2*this.s[1]]; // translations
		this.setAttribute("transform","translate("+this.t[0]+","+this.t[1]+")");
		this.m=[0,0];
		this.M=[0,0];
		// Create axes
		this.ax=this.Line(0,0,0,0,"#777",1);
		this.ay=this.Line(0,0,0,0,"#777",1);
		// Create ticks
		this.ticks=[this.Group(), this.Group()]; // x and y
		this.nt=[22, 16]; // approximate number of ticks
		for(i=0; i<2*this.nt[0]; i+=1) { this.ticks[0].Line(0,0,0,0,"#777",0); }
		for(i=0; i<2*this.nt[1]; i+=1) { this.ticks[1].Line(0,0,0,0,"#777",0); }
		// Create tick labels with an optional "tspan" for powers.
		this.tickL=[this.Group(), this.Group()];
		for(i=0; i<2*this.nt[0]; i+=1) { this.tickL[0].Text(" ",0,0,12,"#777",'NC').Tspan("",-5/this.s[0]).setAttribute("dy",-5); }
		for(i=0; i<2*this.nt[1]; i+=1) { this.tickL[1].Text(" ",0,0,12,"#777",'MW').Tspan("",-5/this.s[0]).setAttribute("dy",-5); }
		// Create curve
		this.quickCurve=this.Polyline([0,0],"#4bb",2);
		this.curve=this.Path("","#4bb",2);
		this.np=2000;
		this.points=new Array(2*this.np);
		
		// Add replotting management after scrolling
		this.update = function() {
			this.curve.setAttribute("d","");
			this.x1=-this.t[0]/this.s[0]; this.x2=this.b[0]/this.s[0]+this.x1;
			this.y2=-this.t[1]/this.s[1]; this.y1=this.b[1]/this.s[1]+this.y2;
			this.m[0]=2*this.x1-this.x2; this.m[1]=2*this.y1-this.y2;
			this.M[0]=2*this.x2-this.x1; this.M[1]=2*this.y2-this.y1;
			// Update axes
			this.ax.sets({"x1":""+this.m[0]*this.s[0], "x2":""+this.M[0]*this.s[0]});
			this.ay.sets({"y1":""+this.m[1]*this.s[1], "y2":""+this.M[1]*this.s[1]});
			// Update ticks and labels
			var z,r,i,j,t,s,n,z1,z2,k,kk,zz,al,p=0,q=0;
			al=['NC','MW']; zz=[1,1]; // tick label alignment
			if(this.b[1]<2*this.t[1]) { al[0]='SC'; zz[1]=-1; } // reverse tick alignment if out of box
			if(this.b[0]<2*this.t[0]) { al[1]='ME'; zz[0]=-1; } //  depending on axes position
			for(k=0; k<2; k+=1) { // x then y
				kk=(k+1)%2;
				z1=[ (this.x2-this.x1)*0.005,-(this.y2-this.y1)*0.01]; // small offsets for ticks
				z2=[-(this.x2-this.x1)*0.005, (this.y2-this.y1)*0.01];
				t = this.ticks[k].childNodes; l=this.tickL[k].childNodes; // get all ticks
				p=(this.M[k]-this.m[k])/this.nt[k]; r=Math.pow(10.,ndec(p));
				q=Math.floor(Math.sqrt(1.5*(p/r-1))); q=(1+q*q)*r; // now q is tick separation
				p=Math.max(ndec(this.m[k]),ndec(this.M[k]))-1; r=Math.pow(10.,p); // p is the power
				i=0;
				for(z=this.m[k]-this.m[k]%q;z<this.M[k];z+=q) { // for each tick position
					z1[k]=z; z2[k]=z;
					t[i].sets({"x1":""+z1[0]*this.s[0],"x2":""+z2[0]*this.s[0],"y1":""+z1[1]*this.s[1],"y2":""+z2[1]*this.s[1],
						"stroke-width":z?1:0});
					s=""; n="";
					if(p*p>9) { // if too long number, display with power of 10
						s=tickformat(z/r,q/r);
						switch(s) {
							case "0": s=""; break;
							case "1": s="10"; n=""+p; break;
							case "-1": s="-10"; n=""+p; break;
							default: s+="·10";""; n=""+p;
						}
					} else { 
						s=tickformat(z,q);
						if(s=="0") { s=""; }
					}
					l[i].childNodes[0].textContent=s;
					l[i].childNodes[1].textContent=n;
					l[i].move((kk+2*zz[0]*k)*z1[0]*this.s[0],-(-zz[1]*2.5*kk-k)*z1[1]*this.s[1],al[k]);
					i+=1;
				}
				for(j=i; j<2*this.nt[k]; j+=1) { //hide unused ticks
					t[j].setAttribute("stroke-width",0);
					l[j].childNodes[0].textContent=""; l[j].childNodes[1].textContent="";
				}
			}
		};
		
		this.quickUpdate = function() {
			this.update();
			// Update curve with 2000 points
			var l=(this.M[0]-this.m[0])/this.np;
			var i=0,y;
			for(var x=this.m[0]; x<this.M[0]; x+=l) {
				y=this.curveEq(x);
				if(isFinite(y)) {
					this.points[i*2]=x*this.s[0];
					this.points[i*2+1]=Math.min(Math.max(y,this.m[1]),this.M[1])*this.s[1];
					i+=1;
				}
			}
			this.quickCurve.setAttribute("points",this.points.slice(0,2*i));
		};

		this.fullUpdate = function() {
			this.update();
			// Update curve with as many points as necessary
			this.d="M "+(this.m[0]*this.s[0])+" 0 "; // start svg path
			this.pathState="M";
			this.maxdepth=5; // depth for adaptative finding of min/max
			var l=(this.M[0]-this.m[0])/this.np; // step in x
			var x,x0,x1,y,y0,y1,t,r,discont,dx,dy,k;
			for(x=this.m[0]; x<this.M[0]; x+=l) { // loop over x
				y=this.curveEq(x);
				this.addMorePoints(x,y); // add point to svg path
				x0=x; x1=x+l; y0=y; y1=this.curveEq(x1); // calculate next point
				if(y1<y0) { t=x0; x0=x1; x1=t; t=y0; y0=y1; y1=t; } // sort the two points (min then max)
				r=this.adaptativeMinMax(x,x+l,x0,y0,x1,y1,0); // find min and max of function between them
				if(r[1]<y0) { this.addMorePoints(r[0],r[1]); } // add min if necessary
				if(r[1]<y0 || r[3]>y1) { // if min or max encountered, check whether discontinuity.
					if(Math.abs(r[2]-r[0])>1e-6*Math.max(Math.abs(r[2]),Math.abs(r[0]))) { // if numerical precision is ok
						dx=(r[2]-r[0])*0.1; dy=Math.abs(r[3]-r[1])*0.3; t=0.5*(r[3]+r[1]);
						for(k=0; k<10; k+=1) { // search for intermediate points
							y=this.curveEq(r[0]+k*dx);
							if(Math.abs(y-t)<dy) { break; } // if intermediate point, then not discontinuous
						}
						if(k>8) { this.pathState=""; } // discontinuity
					}
				}
				if(r[3]>y1) { this.addMorePoints(r[2],r[3]); } // add max if necessary
			}
			this.quickCurve.setAttribute("points",[0,0]);
			this.curve.setAttribute("d",this.d);
		};
		
		this.addMorePoints = function(x,y) {
			if(isFinite(y)) {
				if(this.pathState=="") { this.d+="M "; this.pathState="M"; }
				else if(this.pathState=="M") { this.d+="L "; this.pathState="L"; }
				this.d+=(x*this.s[0])+" "+(Math.min(Math.max(y,this.m[1]),this.M[1])*this.s[1])+" ";
			} else {
				this.pathState="";
			}
		};
		
		this.adaptativeMinMax = function(x0,x1,xm,ym,xM,yM,depth) {
		// returns approximate min and max points between x0 and x1, in the form [xm,ym,xM,yM]
			if(depth>=this.maxdepth) {return [xm,ym,xM,yM];}
			this.yy=this.curveEq((x0+x1)*0.5);
			if(this.yy>yM) { xM=(x0+x1)*0.5; yM=this.yy; }
			else if(this.yy<ym) { xm=(x0+x1)*0.5; ym=this.yy; }
			else if(depth>1) { return [xm,ym,xM,yM]; }
			var r1=this.adaptativeMinMax(x0,(x0+x1)*0.5,xm,ym,xM,yM,depth+1);
			var r2=this.adaptativeMinMax((x0+x1)*0.5,x1,xm,ym,xM,yM,depth+1);
			if(r2[1]<r1[1]) { r1[0]=r2[0]; r1[1]=r2[1]; }
			if(r2[3]>r1[3]) { r1[2]=r2[2]; r1[3]=r2[3]; }
			return r1;
		};
	}
	
	// Make SVG plot movable
	var moving=undefined, movu, movx, mov;
	function moveBegin(evt) {
		evt.preventDefault(); // prevent the default svg dragging
		document.onmouseup=moveEnd;
		moving = evt.target.parentNode.firstChild; // e is plot
		moving.c10=evt.clientX; moving.c20=evt.clientY; // initial coordinates
		moving.quickUpdate();
		evt.target.addEventListener("mousemove", moveContinue, false);
	}
	function moveContinue(evt) {
		if(!moving) return;
		movx = [evt.clientX-moving.c10+moving.t[0], evt.clientY-moving.c20+moving.t[1]];
		// move the plot
		moving.setAttribute("transform","translate("+movx[0]+","+movx[1]+")");
		// make sure that the ticks don't move further than the plot box
		movu = 2*movx[0]/moving.b[0]-1; movu=movu*(Math.min(1,1/Math.abs(movu))-1)*moving.b[0]/2;
		moving.ticks[1].setAttribute("transform","translate("+movu+",0)");
		moving.tickL[1].setAttribute("transform","translate("+movu+",0)");
		movu = 2*movx[1]/moving.b[1]-1; movu=movu*(Math.min(1,1/Math.abs(movu))-1)*moving.b[1]/2;
		moving.ticks[0].setAttribute("transform","translate(0,"+movu+")");
		moving.tickL[0].setAttribute("transform","translate(0,"+movu+")");
	}
	function moveEnd(evt) {
		document.onmouseup=null;
		if(!moving) return;
		mov=moving; moving=undefined;
		var t=mov.getAttribute("transform").match(/-?[0-9.]+[eE\+\-0-9]*/g);
		mov.t[0]=parseFloat(t[0]); mov.t[1]=parseFloat(t[1]);
		mov.fullUpdate();
		mov=undefined;
	}
	
	// Make SVG plot zoomable
	var zooming=undefined, zoomtimer=undefined, zplot=undefined, zoom;
	function zoomBegin(evt) {
		evt.preventDefault(); // prevent the default svg dragging
		document.onmouseup=zoomEnd;
		zooming=evt.target.parentNode;
		zplot=zooming.plot;
		zooming.firstChild.setAttribute("fill","#ddd");
		setTimeout(zoomContinue, 50);
	}
	function zoomContinue() {
		if(!zooming) return; 
		zplot.s[0]*=zooming.z[0];
		zplot.s[1]*=zooming.z[1];
		zplot.t[0]=zplot.b[0]/2-zooming.z[0]*(zplot.b[0]/2-zplot.t[0]);
		zplot.t[1]=zplot.b[1]/2-zooming.z[1]*(zplot.b[1]/2-zplot.t[1]);
		zplot.setAttribute("transform","translate("+zplot.t[0]+","+zplot.t[1]+")");
		zplot.quickUpdate();
		setTimeout(zoomContinue, 50);
	}
	function zoomEnd(evt) {
		//if(zoomtimer) {clearInterval(zoomtimer);}
		document.onmouseup=null;
		if(!zooming) return;
		zoom=zooming; zooming=undefined;
		zoom.firstChild.setAttribute("fill","#eee");
		zplot.fullUpdate();
		zoom=undefined; zplot=undefined;
	}
	
	// number of decimal places
	function ndec(num) {return Math.floor(Math.log(Math.abs(num))/Math.log(10)); }

	// Function for testing equal arrays (must not have subarrays)
	function arrayequal(a,b) {
		var na=a.length, nb=b.length;
		if(na!=nb) {return false;}
		for(var i=0;i<na;i+=1) {if(a[i]!=b[i]){return false;}}
		return true;
	}
	// Linear spaced array
	Array.prototype.linspace = function(xmin,xmax) {
		var dx=(xmax-xmin)/(this.length-1.);
		for(var k=0;k<this.length-1;k+=1) { this[k]=xmin+dx*k; }
		this[this.length-1]=xmax;
	}
	// Shrink array towards 0
	Array.prototype.shrinkTowards0 = function(coeff) {
		if(this[0]*this[this.length-1]<0) {
			for(var k=0;k<this.length;k+=1) { this[k]*=coeff; }
		} else if(this[0]>=0) {
			for(var k=1;k<this.length;k+=1) { this[k]=this[0]+(this[k]-this[0])*coeff; }
		} else {
			for(var k=0;k<this.length-2;k+=1) { this[k]=this[this.length-1]+(this[k]-this[this.length-1])*coeff; }
		}
	}
	// Adjust xmin and xmax near 0 to make it nice
	function adjustWith0(xmin,xmax,undetermined) {
		var xm=xmin, xM=xmax;
		if(undetermined) {
			var xmean=(xmin+xmax)*0.5, defaultx=4;
			if(xm*xM>0 && Math.abs(xmean)<defaultx/5 && xM-xm<Math.abs(xmean)/10) {
				xm=Math.min(0, 2*xmean);
				xM=Math.max(0, 2*xmean);
			} else {
				xm=xmean-defaultx;
				xM=xmean+defaultx;
			}
		}
		if(Math.abs(xM+xm)<xM*0.5) { xm=-xM; }
		var dx=(xM-xm)*0.5;
		if( (xm>0 && xm<dx) || (xM<0 && xM>-dx)) { xm-=dx; xM+=dx; }
		return [xm,xM]; 		
	}
	
	// Function to make tick labels nice
	function tickformat(x,q) {
		var l,z,zm=x+"",m=zm.length;
		for(var y=0;y<=q;y+=q) {
			z=(x+y).toExponential().split("e");
			l = z[0].length-1;
			if(l>14) { z[0]=eval(z[0].substring(0,l)).toFixed(10); }
			z = (eval(z.join("e"))-y)+"";
			if(z.length<m) {m=z.length; zm=z;}
		}
		return zm;
	}

-->
</script>
<script language="javascript">
<!--

	// constants
	var co=[], re_co=[];
	co.push('299792458. m*s^(-1)'); re_co.push(/(\W)c(?!\w)/g); // c
	co.push('6.67384e-11 m^3*kg^(-1)*s^(-2)'); re_co.push(/(\W)G(?!\w)/g); // G
	co.push('6.62606957e-34 J*s'); re_co.push(/(\W)h(?!\w)/g); // h
	co.push('1.256637061e-6 N*A^(-2)'); re_co.push(/(\W)mu_?0(?!\w)/g); // mu0
	co.push('8.854187817e-12 F*m^(-1)'); re_co.push(/(\W)e(?:ps)?_?0(?!\w)/g); // eps0
	co.push('1.602176565e-19 C'); re_co.push(/([^\w\.])(?:q_?)?e(?!\w)/g); // q_e
	co.push('5.2917721092e-11 m'); re_co.push(/(\W)a_?0(?!\w)/g); // a_0
	co.push('2.8179403267e-15 m'); re_co.push(/(\W)r_?e(?!\w)/g); // r_e
	co.push('9.10938215e-31 kg'); re_co.push(/(\W)m_?e(?!\w)/g); // m_e
	co.push('1.672621777e-27 kg'); re_co.push(/(\W)m_?p(?!\w)/g); // m_p
	co.push('6.02214129e23 mol^(-1)'); re_co.push(/(\W)N_?A(?!\w)/g); // N_A
	co.push('1.3806488e-23 J*K^(-1)'); re_co.push(/(\W)k_?B(?!\w)/g); // k_B
	co.push('3.141592653589793'); re_co.push(/(\W)pi(?!\w)/gi); // pi
	co.push('7.2973525698e-3'); re_co.push(/(\W)alpha(?!\w)/g); // alpha
	
	// SI units or similar
	var un=["m","kg","s","A","K","mol","cd","rad"];
	var re_u1=[], re_u2=[], rf=[], ru=[];
	re_u1.push(/[Mm]eters?$/);re_u2.push(/m$/); ru.push([1,0,0,0,0,0,0,0]); rf.push(1);
	re_u1.push(/[Gg]rams?$/);   re_u2.push(/g$/); ru.push([0,1,0,0,0,0,0,0]); rf.push(1e-3);
	re_u1.push(/[Ss]econds?$/); re_u2.push(/s$/); ru.push([0,0,1,0,0,0,0,0]); rf.push(1);
	re_u1.push(/[Aa]mperes?$/); re_u2.push(/A$/); ru.push([0,0,0,1,0,0,0,0]); rf.push(1);
	re_u1.push(/[Kk]elvins?$/); re_u2.push(/K$/); ru.push([0,0,0,0,1,0,0,0]); rf.push(1);
	re_u1.push(/[Mm]oles?$/); re_u2.push(/mol$/); ru.push([0,0,0,0,0,1,0,0]); rf.push(1);
	re_u1.push(/[Cc]andelas?$/); re_u2.push(/cd$/); ru.push([0,0,0,0,0,0,1,0]); rf.push(1);
	re_u1.push(/[Rr]adians?$/); re_u2.push(/rad$/); ru.push([0,0,0,0,0,0,0,1]); rf.push(1);
	re_u1.push(/[Hh]ertz$/);   re_u2.push(/Hz$/);ru.push([0,0,-1,0,0,0,0,0]); rf.push(1);
	re_u1.push(/[Nn]ewtons?$/); re_u2.push(/N$/);ru.push([1,1,-2,0,0,0,0,0]); rf.push(1);
	re_u1.push(/[Pp]ascals?$/);re_u2.push(/Pa$/);ru.push([-1,1,-2,0,0,0,0,0]); rf.push(1);
	re_u1.push(/[Jj]oules?$/);  re_u2.push(/J$/);ru.push([2,1,-2,0,0,0,0,0]); rf.push(1);
	re_u1.push(/[Ww]atts?$/);   re_u2.push(/W$/);ru.push([2,1,-3,0,0,0,0,0]); rf.push(1);
	re_u1.push(/[Cc]oulombs?$/);re_u2.push(/C$/); ru.push([0,0,1,1,0,0,0,0]); rf.push(1);
	re_u1.push(/[Vv]olts?$/);   re_u2.push(/V$/);ru.push([2,1,-3,-1,0,0,0,0]); rf.push(1);
	re_u1.push(/[Ff]arads?$/);  re_u2.push(/F$/);ru.push([-2,-1,4,2,0,0,0,0]); rf.push(1);
	re_u1.push(/[Oo]hms?$/);  re_u2.push(/ohm$/);ru.push([2,1,-3,-2,0,0,0,0]); rf.push(1);
	re_u1.push(/[Ss]iemens$/);  re_u2.push(/S$/);ru.push([-2,-1,3,2,0,0,0,0]); rf.push(1);
	re_u1.push(/[Ww]ebers?$/); re_u2.push(/Wb$/);ru.push([2,1,-2,-1,0,0,0,0]); rf.push(1);
	re_u1.push(/[Tt]eslas?$/);  re_u2.push(/T$/);ru.push([0,1,-2,-1,0,0,0,0]); rf.push(1);
	re_u1.push(/[Gg]auss$/);  re_u2.push(/ /);ru.push([0,1,-2,-1,0,0,0,0]); rf.push(1e-4);
	re_u1.push(/[Hh]enrys?$/);  re_u2.push(/H$/);ru.push([2,1,-2,-2,0,0,0,0]); rf.push(1);
	re_u1.push(/[Ll]itres?$/);re_u2.push(/[lL]$/);ru.push([3,0,0,0,0,0,0,0]); rf.push(1e-3);
	re_u1.push(/[Tt]onnes?$/);  re_u2.push(/ /); ru.push([0,1,0,0,0,0,0,0]); rf.push(1e3);
	re_u1.push(/[Ee]lectron[Vv]olts?$/);re_u2.push(/eV$/);ru.push([2,1,-2,0,0,0,0,0]); rf.push(1.602176565e-19);
	re_u1.push(/bars?$/);       re_u2.push(/bar$/);ru.push([-1,1,-2,0,0,0,0,0]); rf.push(1e5);
	var nu=ru.length;
	
	// SI prefixes
	var re_pr1=[], re_pr2=[], pr=[];
	re_pr1.push(/^[Dd]eca$/); re_pr2.push(/^da$/); pr.push(1e1);
	re_pr1.push(/^[Hh]ecto$/); re_pr2.push(/^h$/); pr.push(1e2);
	re_pr1.push(/^[Kk]ilo$/); re_pr2.push(/^k$/); pr.push(1e3);
	re_pr1.push(/^[Mm]ega$/); re_pr2.push(/^M$/); pr.push(1e6);
	re_pr1.push(/^[Gg]iga$/); re_pr2.push(/^G$/); pr.push(1e9);
	re_pr1.push(/^[Tt]era$/); re_pr2.push(/^T$/); pr.push(1e12);
	re_pr1.push(/^[Pp]eta$/); re_pr2.push(/^P$/); pr.push(1e15);
	re_pr1.push(/^[Ee]xa$/); re_pr2.push(/^E$/); pr.push(1e18);
	re_pr1.push(/^[Zz]etta$/); re_pr2.push(/^Z$/); pr.push(1e21);
	re_pr1.push(/^[Yy]otta$/); re_pr2.push(/^Y$/); pr.push(1e24);
	re_pr1.push(/^[Dd]eci$/); re_pr2.push(/^d$/); pr.push(1e-1);
	re_pr1.push(/^[Cc]enti$/); re_pr2.push(/^c$/); pr.push(1e-2);
	re_pr1.push(/^[Mm]illi$/); re_pr2.push(/^m$/); pr.push(1e-3);
	re_pr1.push(/^[Mm]icro$/); re_pr2.push(/^[µu]$/); pr.push(1e-6);
	re_pr1.push(/^[Nn]ano$/); re_pr2.push(/^n$/); pr.push(1e-9);
	re_pr1.push(/^[Pp]ico$/); re_pr2.push(/^p$/); pr.push(1e-12);
	re_pr1.push(/^[Ff]emto$/); re_pr2.push(/^f$/); pr.push(1e-15);
	re_pr1.push(/^[Aa]tto$/); re_pr2.push(/^a$/); pr.push(1e-18);
	re_pr1.push(/^[Zz]epto$/); re_pr2.push(/^z$/); pr.push(1e-21);
	re_pr1.push(/^[Yy]octo$/); re_pr2.push(/^y$/); pr.push(1e-24);
	var npr=pr.length;
	
	// Other units
	re_u1.push(/^[Hh]ectares?$|^ha$/); ru.push([2,0,0,0,0,0,0,0]); rf.push(1e4);
	re_u1.push(/^[Aa]res?$/); ru.push([2,0,0,0,0,0,0,0]); rf.push(100);
	re_u1.push(/^[Dd]egrees?$|^deg$/); ru.push([0,0,0,0,0,0,0,1]); rf.push(0.017453292519943295);
	re_u1.push(/^[Mm]inutes?$|^min$/); ru.push([0,0,1,0,0,0,0,0]); rf.push(60);
	re_u1.push(/^[Hh]ours?$/); ru.push([0,0,1,0,0,0,0,0]); rf.push(3600);
	re_u1.push(/^[Dd]ays?$/); ru.push([0,0,1,0,0,0,0,0]); rf.push(86400);
	re_u1.push(/^[Aa]ngstroms?$/); ru.push([1,0,0,0,0,0,0,0]); rf.push(1e-10);
	re_u1.push(/^amu$/); ru.push([0,1,0,0,0,0,0,0]); rf.push(1.66053886e-27);
	re_u1.push(/^[Ii]nch(?:es)?$$/); ru.push([1,0,0,0,0,0,0,0]); rf.push(0.0254);
	re_u1.push(/^[Ff]oot$|^[Ff]eet$/); ru.push([1,0,0,0,0,0,0,0]); rf.push(0.3048);
	re_u1.push(/^[Yy]ards?$/); ru.push([1,0,0,0,0,0,0,0]); rf.push(0.9144);
	re_u1.push(/^[Mm]iles?$|^mi$/); ru.push([1,0,0,0,0,0,0,0]); rf.push(1609.344);
	re_u1.push(/^[Aa]cres?$/); ru.push([2,0,0,0,0,0,0,0]); rf.push(4046.8564224);
	re_u1.push(/barns?$/); ru.push([2,0,0,0,0,0,0,0]); rf.push(1e-28);
	re_u1.push(/^[Pp]arsecs?$/); ru.push([1,0,0,0,0,0,0,0]); rf.push(3.085677581491e+16);
	re_u1.push(/^[Ll]ight-?[Yy]ears?$|^ly$/); ru.push([1,0,0,0,0,0,0,0]); rf.push(9460730472580800);
	re_u1.push(/^[Ee]rgs?$/); ru.push([2,1,-2,0,0,0,0,0]); rf.push(1e-7);
	re_u1.push(/^atmospheres?$|^atm$/); ru.push([-1,1,-2,0,0,0,0,0]); rf.push(101325.);
	var nu1=ru.length;
	
	// other regular expressions
	var re_err=/[ a-zA-Z0-9=;+\-^*_\/().,]/g, re_in=/ in /, re_eq=/(.+)=/,
		re_ep =/[Ee]\+?(?=[0-9])/g, re_em=/[Ee]-(?=[0-9])/g,
		re_ep1=/#/g, re_em1=/@/g,
		re_pm=/([^\^])-/g, re_s=/\s/g, re_ss=/\(\+/g, re_par=/^\s*\((.+)\)\s*$/g,
		re_unit1=/([0-9\).])\s*([A-Za-z]+)/g,
		re_unit2=/[A-Za-z]/, re_unit3=/([A-Za-z]+)/g;

-->
</script>
</head>

<body>
<div id="cont">
	<div>
		<div style="height:36px">
			<svg width="100" height="36"><g  transform="translate(50,18)">
				<g style="fill:#fafafa;stroke:none">
					<rect width="20" height="4" x="20" y="-12"/><circle cx="30" cy="-2" r="4"/><circle cx="30" cy="-18" r="4"/>
					<rect width="20" height="4" x="-40" y="8"/><circle cx="-30" cy="2" r="4"/><circle cx="-30" cy="18" r="4"/>
				</g>
				<g style="fill:#f2f2f2;stroke:none">
					<rect width="20" height="4" x="-20" y="-12"/><circle cx="-10" cy="-2" r="4"/><circle cx="-10" cy="-18" r="4"/>
					<rect width="20" height="4" x="0" y="8"/><circle cx="10" cy="2" r="4"/><circle cx="10" cy="18" r="4"/>
				</g>
				<g style="fill:#666666;stroke:none">
					<rect width="10" height="2" x="-10" y="-10"/>
					<rect width="10" height="2" x="0" y="8"/>
					<path d="M-10 2 A 4 4 0 1 0 -10 -6 Z"/>
					<path d="M10 -2 A 4 4 0 1 0 10 6 Z"/>
				</g>
			</g></svg>
		</div>
		<textarea id="in" cols="86" rows="1" onkeydown="go(event);" onkeyup="resize();">me*c^2 in keV</textarea>
		<div id="outcont"><div id="out"> </div></div>
		<div id="hcont">
			<div id="help1" onclick="help(this)">Examples</div>
			<div id="help2" onclick="help(this)">Constants</div>
			<div id="help3" onclick="help(this)">Units</div>
			<div id="help1c">
				<br/>
				<table style="width:100%"><tbody id="examples">
					<tr><td>2*3</td></tr>
					<tr><td>18 m * 2 m</td></tr>
					<tr><td>4 watt * 8 second</td></tr>
					<tr><td>4 W * 8 s in J</td></tr>
					<tr><td>4 hours + 2 day in seconds</td></tr>
					<tr><td>c</td></tr>
					<tr><td>1/(4*pi*e0)</td></tr>
					<tr><td>( e0*(3keV) / (e^2*1e23 cm^-3) )^0.5 in nanometer</td></tr>
					<tr><td>x = 1 m; y = 4 km; x*y/(x^2+y^2)</td></tr>
					<tr><td>graph x^2</td></tr>
				</tbody></table>
			</div>
			<div id="help2c">
				<table class="t"><tbody>
					<tr><td>speed of light</td><td>c</td><td>299792458. m s<sup>-1</sup></td></tr>
					<tr><td>gravitational constant</td><td>G</td><td>6.67384 &#215; 10<sup>-11</sup> m<sup>3</sup> kg<sup>-1</sup>s<sup>-2</sup></td></tr>
					<tr><td>Planck constant</td><td>h</td><td>6.62606957 &#215; 10<sup>-34</sup> J s</td></tr>
					<tr><td>magnetic constant</td><td>mu0</td><td>1.256637061 &#215; 10<sup>-6</sup> N  A<sup>-2</sup></td></tr>
					<tr><td>electric constant</td><td>e0</td><td>8.854187817 &#215; 10<sup>-12</sup> F m<sup>-1</sup></td></tr>
					<tr><td>electron charge</td><td>e</td><td>1.602176565 &#215; 10<sup>-19</sup> C</td></tr>
					<tr><td>Bohr radius</td><td>a0</td><td>5.2917721092 &#215; 10<sup>-11</sup> m</td></tr>
					<tr><td>classical electron radius</td><td>re</td><td>2.8179403267 &#215; 10<sup>-15</sup> m</td></tr>
					<tr><td>electron mass</td><td>me</td><td>9.10938291 &#215; 10<sup>-31</sup> kg</td></tr>
					<tr><td>proton mass</td><td>mp</td><td>1.672621777 &#215; 10<sup>-27</sup> kg</td></tr>
					<tr><td>Avogadro number</td><td>NA</td><td>6.02214129 &#215; 10<sup>23</sup> mol<sup>-1</sup></td></tr>
					<tr><td>Boltzmann constant</td><td>kB</td><td>1.3806488 &#215; 10<sup>-23</sup> J K<sup>-1</sup></td></tr>
					<tr><td>&#960;</td><td>pi</td><td>3.141592653589793</td></tr>
					<tr><td>fine-structure constant</td><td>alpha</td><td>7.2973525698 &#215; 10<sup>-3</sup></td></tr>
				</tbody></table>
			</div>
			<div id="help3c">
				<table class="t"><tbody>
					<tr><td>meter</td><td>m</td><td>m</td></tr>
					<tr><td>gram</td><td>g</td><td>0.001 kg</td></tr>
					<tr><td>second</td><td>s</td><td>s</td></tr>
					<tr><td>ampere</td><td>A</td><td>A</td></tr>
					<tr><td>kelvin</td><td>K</td><td>K</td></tr>
					<tr><td>mole</td><td>mol</td><td>mol</td></tr>
					<tr><td>candela</td><td>cd</td><td>cd</td></tr>
					<tr><td>radian</td><td>rad</td><td></td></tr>
					<tr><td>degree</td><td>deg</td><td>0.0174532925 rad</td></tr>
					<tr><td>hertz</td><td>Hz</td><td>s<sup>-1</sup></td></tr>
					<tr><td>newton</td><td>N</td><td>m kg s<sup>-2</sup></td></tr>
					<tr><td>pascal</td><td>Pa</td><td>m<sup>-1</sup> kg s<sup>-2</sup></td></tr>
					<tr><td>joule</td><td>J</td><td>m<sup>2</sup> kg s<sup>-2</sup></td></tr>
					<tr><td>watt</td><td>W</td><td>m<sup>2</sup> kg s<sup>-3</sup></td></tr>
					<tr><td>coulomb</td><td>C</td><td>s A</td></tr>
					<tr><td>volt</td><td>V</td><td>m<sup>2</sup> kg s<sup>-3</sup> A<sup>-1</sup></td></tr>
					<tr><td>farad</td><td>F</td><td>m<sup>-2</sup> kg<sup>-1</sup> s<sup>4</sup> A<sup>2</sup></td></tr>
					<tr><td>ohm</td><td></td><td>m<sup>2</sup> kg s<sup>-3</sup> A<sup>-2</sup></td></tr>
					<tr><td>siemens</td><td>S</td><td>m<sup>-2</sup> kg<sup>-1</sup> s<sup>3</sup> A<sup>2</sup></td></tr>
					<tr><td>weber</td><td>Wb</td><td>m<sup>2</sup> kg s<sup>-2</sup> A<sup>-1</sup></td></tr>
					<tr><td>tesla</td><td>T</td><td>kg s<sup>-2</sup> A<sup>-1</sup></td></tr>
					<tr><td>gauss</td><td></td><td>0.0001 kg s<sup>-2</sup> A<sup>-1</sup></td></tr>
					<tr><td>henry</td><td>H</td><td>m<sup>2</sup> kg s<sup>-2</sup> A<sup>-2</sup></td></tr>
					<tr><td>minute</td><td>min</td><td>60 s</td></tr>
					<tr><td>hour</td><td></td><td>3600 s</td></tr>
					<tr><td>day</td><td></td><td>345600 s</td></tr>
					<tr><td>are</td><td></td><td>100 m<sup>2</sup></td></tr>
					<tr><td>hectare</td><td>ha</td><td>10000 m<sup>2</sup></td></tr>
					<tr><td>litre</td><td>L</td><td>0.001 m<sup>3</sup></td></tr>
					<tr><td>tonne</td><td></td><td>1000 kg</td></tr>
					<tr><td>electronvolt</td><td>eV</td><td>1.60217653 &#215; 10<sup>-19</sup> m<sup>2</sup> kg s<sup>-2</sup></td></tr>
					<tr><td>angstrom</td><td></td><td>10<sup>-10</sup> m</td></tr>
					<tr><td>barn</td><td></td><td>10<sup>-28</sup> m<sup>2</sup></td></tr>
					<tr><td>atmosphere</td><td>atm</td><td>101325 m<sup>-1</sup> kg s<sup>-2</sup></td></tr>
					<tr><td>amu</td><td></td><td>1.66053886 &#215; 10<sup>-27</sup> kg</td></tr>
					<tr><td>inch</td><td></td><td>0.0254 m</td></tr>
					<tr><td>foot</td><td></td><td>0.3048 m</td></tr>
					<tr><td>yard</td><td></td><td>0.9144 m</td></tr>
					<tr><td>mile</td><td>mi</td><td>1609.344 m</td></tr>
					<tr><td>acre</td><td></td><td>4046.8564224 m<sup>2</sup></td></tr>
					<tr><td>parsec</td><td></td><td>3.0856775815 &#215; 10<sup>16</sup> m</td></tr>
					<tr><td>light-year</td><td>ly</td><td>9.4607304726 &#215; 10<sup>15</sup> m</td></tr>
					<tr><td>erg</td><td></td><td>10<sup>-7</sup> m<sup>2</sup> kg s<sup>-2</sup></td></tr>
				</tbody></table>
			</div>
		</div>
	</div>
</div>

<script language="javascript">
<!--
		
	// HTML elements
	var ein  = document.getElementById("in" );
	var eout = document.getElementById("out");

	// Main callback, when Enter is pressed
	function go(e) {
		if(typeof(e)=='undefined' && window.event) { e=window.event; }
		if(e.keyCode==13) {
			if(e.shiftKey) {
				n=parseInt(ein.rows) + 1;
				ein.style.height = (16*n)+"px";
				ein.rows = n;
			} else { e.preventDefault(); calcstart(); }
		}
		return false;
	}
	function resize() {
		var n=ein.value.split("\n").length;
		ein.style.height = (16*n)+"px";
		ein.rows = n;
	}
	
	// Replace physical constants in a string
	function constants(s) {
		for(var i=0; i<co.length; i+=1) {s=s.replace(re_co[i],"$1("+co[i]+")");}
		return s;
	}

	// Initiate calculation
	var graph;
	function calcstart() {
		eout.innerHTML = "";
		
		var sin=ein.value, sout ="", varout=[], varname,
			i,j,k,l,u,v,us,newu,newu0,s,ss,sss,tm,tp,ok,
			gcont,g,gw,gh,rect,zoom,lx,ly,x,y,w,h,f,b,expr;
		sin=sin.split("\n").join(";").replace(/;+/g,";");
			
		// wrong characters
		var err=sin.replace(re_err,'');
		if(err.length>0) {
			eout.innerHTML = "Unaccepted characters: "+err;
			return;
		}
		
		// loop each of the inputs delimited by ";"
		sin=sin.split(";");
		for(j=0; j<sin.length; j+=1) {
			s=sin[j];
			if(s.trim().length==0) {continue}
			
			// if begins with "graph", then graph something
			graph=false;
			if(s.trim().substring(0,6)=="graph ") {
				graph=true;
				s=s.trim().substring(6);
			}
			
			// if "in" is included, it means a change of units
			s=s.replace(re_in,";").split(';');
			newu="";
			if(s.length>1) {
				if(graph) { eout.innerHTML = "Cannot graph and change units."; return; }
				newu0=s[1];
				newu=newu0.replace(re_s,"");
				newu="("+newu+")"; // newu contains the target units
			}
			s=s[0]; // s now contains the expression (before "in")
			
			// if "=" appears, then it means an assignment
			s=s.replace(re_eq,"$1;").split(';');
			varname="";
			if(s.length>1) {
				if(graph) { eout.innerHTML = "Cannot graph an assignment."; return; }
				varname=s[0].trim(); s[0]=s[1]; // save variable name
				if(!/^[a-zA-Z]+\w*$/.test(varname)) { // verify variable name
					eout.innerHTML = "Unaccepted variable name: "+varname; return; }
				v="("+varname+")";
				if(v!=constants(v)) { // verify not ambiguous w constants
					eout.innerHTML = "Variable name ambiguous with physical constants: "+varname; return; }
				u=segment(varname); u=u[0];
				if(u!="Error:") { // verify not ambiguous w units	
					eout.innerHTML = "Variable name ambiguous with units: "+varname; return; }
			}
			s=s[0]; // s now contains the expression
			expr = "";
			if(sin.length>1 && varname.length==0) expr=s;
	
			s="("+s+")";
			// constants
			s=constants(s);
			// user-defined variables
			for(i=0;i<varout.length;i+=1) { s=s.replace(varout[i][0],"$1("+varout[i][1]+")$2"); }
			// manage e, E, + and - (the - are replaced by +(-1)*)
			s=s.replace(re_em,'@').replace(re_ep,'#').replace(re_pm,'$1+(-1)*');
			// Manage units
			s=s.replace(re_unit1,"$1*$2");
			// Remove spaces; Replace (+ with (
			s=s.replace(re_s,"").replace(re_ss,"(").replace(")(",")*(");

			// Calculate. The output should be a 2-element array containing 
			// the result and the units.
			s=calc(s);
			
			// If the output contains "Error:" then it has an error.
			// Else, we make the output nice.
			if(s[0]!="Error:") {
				if(graph) {
					// Create the svg container
					gcont=document.createElement("div"); g=document.createElementNS(svgns,"svg");
					gcont.className="graphcont";
					gcont.appendChild(g); eout.appendChild(gcont);
					gw=gcont.clientWidth ; g.setAttribute("width" ,gw+"px");
					gh=gcont.clientHeight; g.setAttribute("height",gh+"px");
					// We create "plot" which groups all elements in the graph for easy scrolling
					plot=g.Group();
					// Create a function that represents the curve, and find the best boundaries
					plot.curveEq = new Function("x","return "+s[0].split("|").join("x")+";");
					b=findBestBounds(plot);
					if(!b) { eout.innerHTML = "Error:<br/>cannot graph the function."; }
					plot.init(b[0],b[1],b[2],b[3],gw,gh); // initialize the plot
					// Create a transparent overlay for detecting mousedown
					rect=g.Rect(0,0,gw,gh,"transparent","transparent",0);
					rect.onmousedown = moveBegin;
					// Create zoom buttons
					x=5;y=5;w=14;h=14;
					g.ZoomButton(x,y,w,h,"+").z=[1.1,1.1];
					g.ZoomButton(x,y+h,w,h,"-").z=[1/1.1,1/1.1];
					x+=w*2; w*=2/3; h*=2/3;
					g.ZoomButton(x,y,w,h,"+").z=[1,1.1];
					g.ZoomButton(x,y+2*h,w,h,"-").z=[1,1/1.1];
					x-=w; y+=h;
					g.ZoomButton(x+2*w,y,w,h,"+").z=[1.1,1];
					g.ZoomButton(x,y,w,h,"-").z=[1/1.1,1];
					// Draw the plot
					plot.fullUpdate();
					continue;
				}
			
				// Now we make units readable
				u=""; v=s[0];
				if(newu=="") { // if no change of units requested,
					for(l=0;l<8;l+=1) { // for each of m kg s A K mol cd rad,  
						if(s[1][l]) { // print unit if exists.
							u+=un[l];
							if(s[1][l]!=1) { u+="<sup>"+s[1][l]+"</sup>"; }
							u+=" ";
						}
					}
				} else { // if change of units requested,
					us=calc(newu); // calculate units as if normal expression.
					if(!arrayequal(us[1],s[1])) { // error if different units.
						eout.innerHTML = "Error:<br/>requested units don't match.";
						return;
					}
					u=newu0.replace(/\^([0-9.\-]+)/g,"<sup>$1</sup>");
					v/=us[0]; // divide the original result by the new units.
				}
				// Resolve some problems of precision
				v=eval(eval(v).toExponential(15))+"";
				if(v>1000. && v.length>10) { v=eval(v).toExponential(10); }
				ss = v.split('e');
				sss = ss[0];
				l = sss.length-1;
				if(l>8) {
					sss = (sss.replace(/[0-9]/g,"0").substring(0,l))+"1";
					tm=(parseFloat(ss[0])-parseFloat(sss))+"";
					tp=(parseFloat(ss[0])+parseFloat(sss))+"";
					if     (tm.length<l-4) { ss[0]=tm; }
					else if(tp.length<l-4) { ss[0]=tp; }
				}
				// Space every 3 digits
				sss = ss[0].split(".");
				k = sss[0].length % 3;
				try{ sss[0] = sss[0].substring(0,k) + " "
							+ sss[0].substring(k).match(/[0-9]{3}/g).join(" "); }
				catch(e) {}
				if(sss.length>1) {
					sss[1]=sss[1].replace(/0*$/,""); // remove trailing zeros
					k = sss[1].length - (sss[1].length % 3);
					try{ sss[1] = sss[1].substring(0,k).match(/[0-9]{3}/g).join(" ")
								+ " " + sss[1].substring(k); }
					catch(e) {}
				} else { sss.push(""); }
				
				if(sss[1].length==0) { ss[0]=sss[0]; }
				else { ss[0] = sss.join("."); }
	
				// Rebuild the string
				v = ss[0];
				if(ss.length>1) {
					ss[1]="10<sup>"+parseInt(ss[1])+"</sup>"; // Convert exponentiation
					if(v=="1") { v=ss[1]; }
					else { v=v+" &#215; "+ss[1]; }
				}
					
				// Manage storing to a variable
				if(varname.length>0) {
					us=" ";
					for(l=0;l<8;l+=1) { // for each of m kg s A K mol cd rad,  
						if(s[1][l]) { // print unit if exists.
							if(l>0) {us+="*";}
							us+=un[l];
							if(s[1][l]!=1) { us+="^"+s[1][l]; }
						}
					}
					// In varout, we store a regexp to recognize the variable, and a replacement value
					varout.push([new RegExp("(\\W)"+varname+"(\\W)","g"), s[0]+us]);
					v = varname+" = "+v;
				} else if(expr.length>0) {
					v = expr+" = "+v;
				}
				
				s[0]=v; s[1]=u;
			}
			
			// Output
			if(j>0) {eout.innerHTML += "<br/>";}
			eout.innerHTML += s[0]+"&nbsp;&nbsp;&nbsp;<font style=\"color:#77b\">"+s[1]+"</font>";
		}
	}
	
	// Parse the string and calculate
	function calc(s) {
		var i,j=0,k=0,l,ss=[],uu=[],kk=[],ff=[],rr=[],sss,u,uuu,f,t,n,seg;
		
		// Loop each character in the expression
		for(i=0; i<s.length; i+=1) {
		
			switch(s[i]) { 
				case '(':
					sss=s.substring(j,i); j=i+1; // get the string before "("
					ff.push([0,""]); // temporarily empty (may contain a function)
					if(sss.length>0) { // if "(" preceded by string, must be a function
						switch(sss) { // Convert function to javascript.
							case "cos": case "sin": case "tan": // radian argument only
								ff[ff.length-1]=[1,"Math."+sss+"(",sss];
								break;
							case "cosh": case "sinh": case "tanh":
								ff[ff.length-1]=[2,"Math."+sss+"(",sss];
								break;
							case "acos": case "asin": case "atan": case "acosh": case "asinh": case "atanh":
								ff[ff.length-1]=[2,"Math."+sss+"(",sss];
								break;
							case "exp": case "log10":
								ff[ff.length-1]=[2,"Math."+sss+"(",sss];
								break;
							case "ln":
								ff[ff.length-1]=[2,"Math.log(",sss];
								break;
							case "ceil": case "floor": case "round": case "abs": case "sign": // unit-conserving functions only
								ff[ff.length-1]=[3,"Math."+sss+"(",sss];
								break;
							case "max": case "min": // functions with several arguments
								ff[ff.length-1]=[4,"Math."+sss+"(",sss];
								break;
							case "sqrt":
								ff[ff.length-1]=[5,"Math."+sss+"(",sss];
								break;
							default:
								return ["Error:","unknown function "+sss+"."];
						}
					} // Now ff contains info about function if any.
					k+=1; // Augment parenthesis level.
					break;
					
				case ')':
					seg=s.substring(j,i); j=i+1; // get the string before ")"
					
					sss=segment(seg); // Evaluate the string as math expression.
					if(sss[0]=="Error:") return sss;
					ss.push(sss[0]); kk.push(k); uu.push(sss[1]); rr.push(seg); // Store result.
					
					// now ss contains a list of previous values
					// uu contains a list of previous units
					// kk contains a list of previous "parenthesis levels"
					sss=""; uuu=[[0,0,0,0,0,0,0,0]]; // sss and uuu are temporary.
					
					// We now loop backwards to sum all content of the parenthesis.
					while(kk[kk.length-1]==k) {
						//alert("====\n"+ss+"\n"+kk+"\n"+uu+"\n"+sss);
						// Get the information of the previous stored values.
						t=ss[ss.length-1]; u=uu[uu.length-1]; seg=rr[rr.length-1];
						ss.pop(); kk.pop(); uu.pop(); rr.pop(); // remove info.
						// If units=="!", it means it was an operator (+-/*^) => impossible
						if(u=="!") { return ["Error:","operator mismatch."]; }
						
						// Now, we look one more time backwards, expecting an operator.
						
						// The "^" are treated first.
						while(ss[ss.length-1]=="^" && kk[kk.length-1]==k) {
							if(!arrayequal(u,[0,0,0,0,0,0,0,0])) // units must be 0 inside a "^".
								{ return ["Error:","non-dimensionless power expression."];}
							ss.pop(); kk.pop(); uu.pop(); rr.pop(); // remove info. 
							u=uu[uu.length-1]; t=eval(t); // Move once more backwards: evaluate expression.
							for(l=0;l<8;l+=1) { u[l]*=t; } // Take units to the power.
							t="Math.pow("+ss[ss.length-1]+","+t+")"; // Convert power to javascript.
							ss.pop(); kk.pop(); uu.pop(); rr.pop(); // remove info.
						}
						
						// If we reached the end of the parenthesis, stop moving backwards.
						if(kk[kk.length-1]!=k) {
							for(l=0;l<8;l+=1) { uuu[uuu.length-1][l]+=u[l]; } // combined units.
							sss=t+sss; // combined expression.
							break; // exit loop backwards.
						}
						
						// Special case of ambiguity such as "1/2m"
						if(uu.length>2) {
							var u2 = uu[uu.length-2], s2 = ss[ss.length-2], k3 = kk[kk.length-3], s3 = ss[ss.length-3], r4=rr[rr.length-4];
							if(k==k3 && !arrayequal(u,[0,0,0,0,0,0,0,0]) && arrayequal(u2,[0,0,0,0,0,0,0,0]) && s3=="/") {
								return ["Error:","\"("+r4+"/"+s2+")"+seg+"\" ambiguous with \""+r4+"/("+s2+seg+")\""];
							}
						}
						
						// Now we treat the other operators.
						switch(ss[kk.length-1]) {
							case "*": // If multiplication,
								for(l=0;l<8;l+=1) { uuu[uuu.length-1][l]+=u[l]; } // add power to units.
								sss="*"+t+sss; ss.pop(); kk.pop(); uu.pop(); rr.pop();
								break;
							case"/": // If division, 
								for(l=0;l<8;l+=1) { uuu[uuu.length-1][l]-=u[l]; } // substract power to units.
								sss="/"+t+sss; ss.pop(); kk.pop(); uu.pop(); rr.pop();
								break;
							case "+": // If addition,
								for(l=0;l<8;l+=1) { uuu[uuu.length-1][l]+=u[l]; }
								sss="+"+t+sss; ss.pop(); kk.pop(); uu.pop(); rr.pop();
								uuu.push([0,0,0,0,0,0,0,0]); // begin new units.
								break;
							case ",":
								if(ff[ff.length-1][0]!=4) return ["Error:","Unaccepted ','"]; // only in functions with multiple arguments
								for(l=0;l<8;l+=1) { uuu[uuu.length-1][l]+=u[l]; }
								sss=","+t+sss; ss.pop(); kk.pop(); uu.pop(); rr.pop();
								uuu.push([0,0,0,0,0,0,0,0]); // begin new units.
								break;
						}
					}
					// Now we finished the loop to combine the parenthesis,
					k-=1; // and we go up one level.
					
					// We verify that units are consistent for a sum.
					for(l=1;l<uuu.length;l+=1) {
						if(!arrayequal(uuu[l],uuu[0])) { return ["Error:","unit mismatch."]; }
					}
					
					// If the parenthesis is preceded by a function, it was saved in ff.
					f=ff[ff.length-1]; ff.pop();
					if(f[0]>0) {
						sss=f[1]+sss+")"; // Add function to expression.
						// if cos, sin or tan, allow radians
						if(f[0]==1 && uuu[0][7]==1) { uuu[0][7]=0; }
						// Do not allow units in some functions.
						if(f[0]==2 && !arrayequal(uuu[0],[0,0,0,0,0,0,0,0])) {
							return ["Error:","Function "+ff[2]+" should have dimensionless argument."];
						}
						// Change units for sqrt
						if(f[2]=="sqrt") for(l=0;l<8;l+=1) uuu[0][l]*=0.5;
					}
					
					// Try to evaluate the final expression in parenthesis.
					if(graph && sss.indexOf("|")>=0) {
						ss.push('('+sss+')');
					} else {						
						try{ss.push(""+eval(sss))}
						catch(e) {return ["Error:","cannot evaluate "+sss];}
					}
					kk.push(k); uu.push(uuu[0]); rr.push("?"); // store the result.
					break;

				case '+': case'*': case'/': case '^': case ',':
					seg=s.substring(j,i); j=i+1; // get the string before operator.
					if(seg.length>0) {
						sss=segment(seg); // calculate the expression before operator.
						if(sss[0]=="Error:") return sss;
						ss.push(sss[0]); kk.push(k); uu.push(sss[1]); rr.push(seg); // store result.
					}
					ss.push(s[i]); kk.push(k); uu.push("!"); rr.push(s[i]); // store operator.
					break;
			}
		}
		ss=ss[0]; uu=uu[0];
		// Now, ss contain the value, and uu the units
		
		// Error if parentheses not finished
		if(k>0) return ["Error:","missing parentheses"];
		
		return [ss,uu];
	}
	
	// Analyzes a segment with either a math expression or units.
	function segment(sss) {
		var i=sss.search(re_unit2),j,k,l,ok;

		// case of the "x" variable
		if(graph && (sss=="x" || sss=="-x")) {
			return [sss.replace("x","(|)"), [0,0,0,0,0,0,0,0]];
		} 

		if(i<0) { // If just a number,
			sss=[sss,[0,0,0,0,0,0,0,0]]; // indicate no units.
			// Convert back # and @ to E or E-
			// and evaluate expression
			sss[0]=eval(sss[0].replace(re_ep1,'E').replace(re_em1,'E-'));
		} else { // If units, 
			var u=sss.substring(i),v,w,x,ru_=[0,0,0,0,0,0,0,0],rf_=1,pr_;
			sss=sss.substring(0,i);
			// now u contains units and sss contains the value.
			if(sss.length==0) {sss="1";} // if no value, then assume 1.
			u=u.replace(re_unit3,";$1").split(';'); // Separate units (m kg s A K mol cd rad).
			for(j=1; j<u.length; j+=1) { // For each units,
				v=u[j].split("&"); // If there is a "&", it means "^".
				w=1; if(v.length>1) { w=v[1]; } // Now w contains the exponent.
				v=v[0]; // Now v contains the name of units.
				ok=0; pr_=1;
				// Search in known full units (meter gram second etc.)
				for(k=0; k<nu; k+=1) { // Loop known units
					if(re_u1[k].test(v)) { // If unit found
						l=v.search(re_u1[k]); // index where found
						if(l>0) { // if something else, see if it is a prefix
							x=v.substring(0,l);
							for(l=0;l<npr;l+=1) { // loop available prefixes
								if(re_pr1[l].test(x)) {ok=1;pr_=pr[l];break;}
							}
							if(ok==1) break;
						} else {
							ok=1; break;
						}
					}
				}
				// Search in known abbreviated units (m g s etc.)
				if(ok==0) {
					for(k=0; k<nu; k+=1) { // loop units
						if(re_u2[k].test(v)) { // if unit found
							l=v.search(re_u2[k]); // index where found
							if(l>0) { // if something else, see if it is a prefix
								x=v.substring(0,l);
								for(l=0;l<npr;l+=1) { // loop available prefixes
									if(re_pr2[l].test(x)) {ok=2;pr_=pr[l];break;}
								}
								if(ok==2) break;
							} else {
								ok=2; break;
							}
						}
					}
				}
				// Search in other units (inch parsec etc.)
				if(ok==0) {
					for(k=nu; k<nu1; k+=1) { // loop units
						if(re_u1[k].test(v)) { // if unit found
							ok=3; break;
						}
					}
				}
				// If units not found, error
				if(ok==0) { return ["Error:","unknown units "+v]; }
				// Apply units with prefix and factor
				for(l=0;l<8;l+=1) { ru_[l]+=w*ru[k][l]; }
				rf_*=Math.pow(rf[k]*pr_,w);
			}
			try{sss=eval(sss)}
			catch(e) {return ["Error:","cannot evaluate "+sss];}
			sss=[eval(sss+"*"+rf_), ru_];
		}
		
		return sss;
	}
	
	// Displays help
	function help(e) {
		ee=document.getElementById(e.id+"c");
		if(ee.style.display!="block") {
			for(var i=1; i<4; i+=1) {
				document.getElementById("help"+i).style.color="#777";
				document.getElementById("help"+i+"c").style.display="none";
			}
			e.style.color="#000";
			ee.style.display="block";
		} else {
			e.style.color="#777";
			ee.style.display="none";
		}
	}
	
	// Make examples clickable
	var exa = document.getElementById("examples").getElementsByTagName("tr");
	for(var k=0; k<exa.length; k+=1) {
		exa[k].style.cursor = "pointer";
		exa[k].onclick = function(){ein.value=this.childNodes[0].innerHTML; resize(); calcstart();};
	}
	
	// If the URL contains the formula embedded, then use that
	var URLeq=location.search;
	if(URLeq.length>0) {
		URLeq=URLeq.substring(1);
		if(URLeq.length>0) { ein.value=URLeq; }
	}
	
	resize();
-->
</script>
</body>

</html>